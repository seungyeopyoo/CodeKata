// 크기가 작은 부분문자열

// 숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서,
// 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요.

// 예를 들어, t="3141592"이고 p="271" 인 경우, t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다.
// 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.

// 1 ≤ p의 길이 ≤ 18
// p의 길이 ≤ t의 길이 ≤ 10,000

//     t	           p	     result
// "3141592"	     "271"	        2
// "500220839878"	  "7"	        8
// "10203"	         "15"	        3

// 입출력 예 #2
// p의 길이가 1이므로 t의 부분문자열은 "5", "0", 0", "2", "2", "0", "8", "3", "9", "8", "7", "8"이며
// 이중 7보다 작거나 같은 숫자는 "5", "0", "0", "2", "2", "0", "3", "7" 이렇게 8개가 있습니다.

// 입출력 예 #3
// p의 길이가 2이므로 t의 부분문자열은 "10", "02", "20", "03"이며, 이중 15보다 작거나 같은 숫자는 "10", "02", "03" 이렇게 3개입니다.
// "02"와 "03"은 각각 2, 3에 해당한다는 점에 주의하세요

// t가 주어지고  p의 길이 만큼 t를 맨앞부터 한칸씩 slice하여 부분문자열을 출력한다. 한칸씩 넘어가면서 어떻게 출력하지..
// slice 한것을 for문으로 나열한다.
// 출력된 문자열을 숫자로 반환하여 P보다 작거나 같은 것을 count++한다.

function solution(t, p) {
	const pLength = p.length; // p의 길이
	const pValue = parseInt(p); // p를 정수로 변환
	let count = 0; // 조건을 만족하는 부분 문자열의 개수를 세기 위한 변수

	// t의 길이에서 p의 길이를 뺀 만큼 반복
	for (let i = 0; i <= t.length - pLength; i++) {
		// 현재 위치에서 p의 길이만큼 잘라서 부분 문자열을 얻음
		const substring = t.slice(i, i + pLength);
		// 부분 문자열을 정수로 변환하여 p의 값과 비교
		if (parseInt(substring) <= pValue) {
			count++; // 조건을 만족하면 카운트 증가
		}
	}

	return count; // 최종 결과 반환
}

console.log(solution('3141592', '271')); // 2
